SOMAS Alignment Strategy: Agents & Lifecycle1. Problem & GoalProblem: Divergence between legacy "Neurology" docs (7 stages), current "Aether" code (11 stages), and overlapping agent roles.Goal: Operationalize the 11-stage Aether lifecycle using concrete GitHub primitives (Issues, PRs, Projects) and strictly define "One Agent, One Role."2. Operational Reality: The GitHub Object ModelTo ground SOMAS in reality, we map abstract concepts to physical GitHub artifacts.ConceptGitHub PrimitiveRole & BehaviorThe ContextGitHub IssueThe Source of Truth. It persists across the entire lifecycle. All agent logs and decisions are posted here as comments.The WorkflowGitHub ProjectThe Kanban Board. Columns represent the 11 Aether Stages. Cards (Issues) move left-to-right based on Gate passage.The WorkspacePull Request (PR)The Canvas. Created in Stage 05. This is where code, tests, and docs are drafted. CI checks run here.The StateLabelssomas:stage:05-implement, somas:status:blocked, somas:gate:passed. Triggers workflow transitions.The ReleaseMilestoneGroups Issues into a versioned delivery (e.g., v1.0.0).3. The 11-Stage Lifecycle & Artifact MappingThis table maps the Time (Stage) to the Worker (Agent ID) and the State (Label).IDStage (Column)Primary Agents (YAML ID)GitHub LabelOperational ActionsExit Gate (Criteria)01INTAKEtriage, advisorsomas:stage:01-intakeAgent analyzes Issue body. Checks similarity to existing issues. Assigns difficulty.feasibility > 0.702SPECIFYspecifiersomas:stage:02-specifyAgent creates/updates docs/specs/ISSUE-123.md. Converts intent to strict PRD.spec_approved03PLANplanner, architect, simulatorsomas:stage:03-planArchitect defines folder structure. Planner generates plan.json. Simulator runs Monte Carlo pathing.architecture_valid04DECOMPOSEdecomposersomas:stage:04-decomposeBreaks plan.json into atomic sub-tasks linked to the Issue.tasks_created05IMPLEMENTimplementer, copilotsomas:stage:05-implementCreate PR. Loop: Write Code $\rightarrow$ Run CI $\rightarrow$ Fix Errors. (See Micro-Loop below)build_success06VERIFYtester, debuggersomas:stage:06-verifyRuns deep test suites on the PR. Debugger patches logic if tests fail.tests_pass07INTEGRATEmerger, validatorsomas:stage:07-integrateChecks for merge conflicts with main. Validates requirements traceability.clean_merge08HARDENsecuritysomas:stage:08-hardenRuns SAST/DAST on PR. Checks for secrets/vulns.security_clean09RELEASEdeployersomas:stage:09-releaseMerges PR to main. Tags release. Generates Changelog.merged10OPERATEoperatorsomas:stage:10-operateDeploys to env. Checks health endpoints.health_200_ok11ANALYZEanalyzer, documentersomas:stage:11-analyzeReviews metrics (time-to-merge, retries). Updates strictness of Gates.metrics_logged4. The Fractal Lifecycle (Micro-Loops)As noted in the strategy, a Stage is not just a single step. It is a container for a micro-lifecycle.Example: The "Stage 05 (Implement)" Micro-LoopWhile the Issue is in the IMPLEMENT column (somas:stage:05-implement), the PR undergoes its own cycle before moving to Stage 06:Draft: implementer writes feature.py.Build: GH Actions triggers syntax_check.Document: documenter adds docstrings to the new code.Review: copilot (or reviewer) performs a "sanity check" (linting).Refine: implementer fixes syntax errors.Result: A compilable, linted PR.Next: Move to VERIFY (somas:stage:06-verify) for functional correctness testing.5. Agent Scope ResolutionResolving overlapping responsibilities to enforce the lifecycle above.Coder vs. ImplementerResolution: Implementer (implementer.yml) is the Agent. Coder is deprecated. The Implementer owns the Stage 05 Micro-Loop.Tester vs. ValidatorResolution:Tester (tester.yml): "Does the code work?" (Unit/Integration Tests).Validator (validator.yml): "Did we build the right thing?" (Reqs Traceability).Planner vs. ArchitectResolution:Architect (architect.yml): Spatial design (Files, Classes, DB Schema).Planner (planner.yml): Temporal design (Order of operations, Dependencies).6. Orchestrator RoleThe Orchestrator (orchestrator.yml) is the Runtime Engine. It does not appear in the table because it is the table. It manages the movement of the Issue card between columns and invokes the Agents assigned to that column based on the presence of labels like somas:stage:xx.