# @copilot-context: SOMAS main pipeline workflow
# This workflow orchestrates the 7-stage AI development pipeline
# Each stage is handled by specialized AI agents (Codex, Copilot, Gemini)
# 
# GitHub Copilot Custom Agents:
#   - @copilot somas-requirements (Ideation → Specification)
#   - @copilot somas-architect (Architecture)
#   - @copilot somas-implementer (Implementation)
#   - @copilot somas-tester (Implementation → Validation)
#   - @copilot somas-reviewer (Implementation → Validation)
#   - @copilot somas-security (All stages)
#   - @copilot somas-optimizer (Implementation)
#   - @copilot somas-documenter (All stages)
#   - @copilot somas-debugger (Validation)
#   - @copilot somas-merger (Staging)
#   - @copilot somas-orchestrator (Coordination)
#   - @copilot somas-advisor (Strategic planning)
# 
# See .github/agents/README.md for complete agent documentation
# 
# @copilot-review: Ensure security measures are maintained in all stages
name: SOMAS Pipeline

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      project_id:
        description: 'Project ID to process'
        required: true
        type: string
      stage:
        description: 'Pipeline stage to execute'
        required: false
        type: choice
        options:
          - all
          - ideation
          - specification
          - simulation
          - architecture
          - implementation
          - validation
          - staging

permissions:
  contents: write
  issues: write
  pull-requests: write
  projects: write

jobs:
  initialize-pipeline:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'somas-project')
    outputs:
      project_id: ${{ steps.setup.outputs.project_id }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Project
        id: setup
        env:
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
        run: |
          # @copilot-security: Project ID validation prevents path traversal attacks
          # Generate project ID from issue number
          PROJECT_ID="project-${ISSUE_NUMBER}"
          echo "project_id=${PROJECT_ID}" >> $GITHUB_OUTPUT
          
          # Create project directory structure
          mkdir -p .somas/projects/${PROJECT_ID}/{artifacts,logs}
          
          # @copilot-context: Using Python for JSON encoding prevents shell injection
          # Create project metadata using Python for safe JSON encoding
          printf '%s\n' \
            'import json' \
            'import os' \
            'from datetime import datetime' \
            '' \
            'project_id = os.environ["PROJECT_ID"]' \
            'issue_number = int(os.environ["ISSUE_NUMBER"])' \
            'title = os.environ["ISSUE_TITLE"]' \
            'created_at = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")' \
            '' \
            'metadata = {' \
            '    "project_id": project_id,' \
            '    "issue_number": issue_number,' \
            '    "title": title,' \
            '    "created_at": created_at,' \
            '    "status": "initializing",' \
            '    "current_stage": "ideation",' \
            '    "stages_completed": []' \
            '}' \
            '' \
            'with open(f".somas/projects/{project_id}/metadata.json", "w") as f:' \
            '    json.dump(metadata, f, indent=2)' \
            > /tmp/create_metadata.py
          
          python3 /tmp/create_metadata.py
          
          export PROJECT_ID="${PROJECT_ID}"
          echo "Initialized project: ${PROJECT_ID}"
      
      - name: Create GitHub Project Board
        uses: actions/github-script@v7
        with:
          script: |
            const projectId = '${{ steps.setup.outputs.project_id }}';
            
            // Trigger project creation workflow
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'somas-project-event',
              client_payload: {
                project_id: projectId,
                action: 'create'
              }
            });
      
      - name: Commit project initialization
        run: |
          git config user.name "SOMAS Bot"
          git config user.email "somas-bot@users.noreply.github.com"
          
          # Check if there are any changes to commit
          if git status --porcelain .somas/projects/ | grep . >/dev/null; then
            git add .somas/projects/
            git commit -m "Initialize SOMAS project ${{ steps.setup.outputs.project_id }}"
            git push
          else
            echo "No changes to commit"
          fi
  
  stage-1-ideation:
    # Agent Assignment: @copilot somas-requirements
    # Responsible for: Extracting and structuring requirements from issue
    # Output: requirements_analysis.md in project artifacts
    # Feeds into: Codex Specifier agent
    runs-on: ubuntu-latest
    needs: [initialize-pipeline]
    if: |
      (github.event_name == 'issues' || github.event_name == 'workflow_dispatch') &&
      (needs.initialize-pipeline.result == 'success' || github.event.inputs.stage == 'ideation' || github.event.inputs.stage == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
      
      - name: Run Ideation Stage
        # Agent: @copilot somas-requirements extracts structured requirements
        # from the issue and prepares input for specification stage
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          echo "Running ideation stage for ${PROJECT_ID}"
          
          # Placeholder for actual ideation agent execution
          mkdir -p .somas/projects/${PROJECT_ID}/artifacts
          echo "# Initial Plan" > .somas/projects/${PROJECT_ID}/artifacts/initial_plan.md
          echo "Stage 1: Ideation completed" >> .somas/projects/${PROJECT_ID}/artifacts/initial_plan.md
  
  stage-2-specification:
    # Agent Assignment: Codex Specifier (primary)
    # Supporting: @copilot somas-requirements (provides structured input)
    # Responsible for: Creating complete, unambiguous SPEC.md
    # Output: SPEC.md with all requirements documented
    runs-on: ubuntu-latest
    needs: [initialize-pipeline, stage-1-ideation]
    if: |
      always() &&
      (needs.stage-1-ideation.result == 'success' || github.event.inputs.stage == 'specification' || github.event.inputs.stage == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
      
      - name: Run Specification Stage
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          echo "Running specification stage for ${PROJECT_ID}"
          
          # Specification artifact generation
          ARTIFACT_DIR=".somas/projects/${PROJECT_ID}/artifacts"
          SPEC_TEMPLATE=".somas/templates/SPEC.md"
          SPEC_OUTPUT="${ARTIFACT_DIR}/SPEC.md"
          
          mkdir -p "${ARTIFACT_DIR}"
          
          if [ -f "${SPEC_TEMPLATE}" ]; then
            echo "Using existing specification template at ${SPEC_TEMPLATE}"
            cp "${SPEC_TEMPLATE}" "${SPEC_OUTPUT}"
          else
            echo "Specification template not found at ${SPEC_TEMPLATE}; generating a basic specification file instead."
            cat > "${SPEC_OUTPUT}" << 'SPECEOF'
            # Specification for project ${PROJECT_ID}
            
            This is an auto-generated specification artifact for the project.
            
            Please update this document with detailed functional, non-functional, and interface requirements for the project.
            SPECEOF
          fi
          
          echo "Stage 2: Specification completed"
      
      - name: Update Project Status
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'somas-project-event',
              client_payload: {
                project_id: '${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}',
                action: 'update',
                stage: 'specification'
              }
            });
  
  stage-3-simulation:
    # Agent Assignment: Codex Simulator
    # Responsible for: Monte Carlo simulation for optimal task execution
    # Output: execution_plan.yml with optimized task sequence
    runs-on: ubuntu-latest
    needs: [initialize-pipeline, stage-2-specification]
    if: |
      always() &&
      (needs.stage-2-specification.result == 'success' || github.event.inputs.stage == 'simulation' || github.event.inputs.stage == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
      
      - name: Run Simulation Stage
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          echo "Running simulation stage for ${PROJECT_ID}"
          
          # Simulation artifact generation
          ARTIFACT_DIR=".somas/projects/${PROJECT_ID}/artifacts"
          PLAN_OUTPUT="${ARTIFACT_DIR}/execution_plan.yml"
          
          mkdir -p "${ARTIFACT_DIR}"
          
          # Generate execution plan YAML
          # In production, this would be generated by the simulator agent
          # For now, generate a basic structure that the dispatch job can parse
          cat > "${PLAN_OUTPUT}" <<-'PLANEOF'
          	optimal_execution_plan:
          	  phase_1:
          	    name: "Foundation"
          	    duration: "8-12 hours"
          	    parallel_tasks:
          	      - task_id: "TASK-001"
          	        name: "Database Schema Design"
          	        duration: 6.5
          	      - task_id: "TASK-002"
          	        name: "API Contract Definition"
          	        duration: 4.2
          	      - task_id: "TASK-003"
          	        name: "Development Environment Setup"
          	        duration: 3.8
          	  phase_2:
          	    name: "Core Implementation"
          	    duration: "18-24 hours"
          	    parallel_tasks:
          	      - task_id: "TASK-005"
          	        name: "Core API Implementation"
          	        duration: 12.3
          	        risk: "HIGH"
          	      - task_id: "TASK-006"
          	        name: "Frontend Component Library"
          	        duration: 10.5
          	      - task_id: "TASK-007"
          	        name: "Authentication Module"
          	        duration: 8.7
          	      - task_id: "TASK-004"
          	        name: "Database Migration Scripts"
          	        duration: 5.2
          	  phase_3:
          	    name: "Integration"
          	    duration: "12-16 hours"
          	    parallel_tasks:
          	      - task_id: "TASK-008"
          	        name: "Integration Testing"
          	        duration: 8.1
          	        risk: "MEDIUM"
          	      - task_id: "TASK-009"
          	        name: "Frontend-Backend Integration"
          	        duration: 7.5
          	simulation_results:
          	  mean_hours: 42.5
          	  median_hours: 40.2
          	  p90_hours: 58.3
          	  standard_deviation: 8.7
          	critical_path:
          	  - task_id: "TASK-001"
          	    name: "Database Schema Design"
          	    probability: 0.89
          	  - task_id: "TASK-005"
          	    name: "Core API Implementation"
          	    probability: 0.95
          	  - task_id: "TASK-008"
          	    name: "Integration Testing"
          	    probability: 0.78
          	PLANEOF
          
          echo "Generated execution plan at ${PLAN_OUTPUT}"
          echo "Stage 3: Simulation completed"
      
      - name: Create Task Issues
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'somas-project-event',
              client_payload: {
                project_id: '${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}',
                action: 'update',
                stage: 'simulation'
              }
            });
  
  stage-4-architecture:
    # Agent Assignment: @copilot somas-architect + Codex Architect
    # Responsible for: System architecture, component design, API specs
    # Output: ARCHITECTURE.md, api_specs.yml, data_models.yml, ADRs
    runs-on: ubuntu-latest
    needs: [initialize-pipeline, stage-3-simulation]
    if: |
      always() &&
      (needs.stage-3-simulation.result == 'success' || github.event.inputs.stage == 'architecture' || github.event.inputs.stage == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Run Architecture Stage
        # Agents: @copilot somas-architect designs system components,
        # working alongside Codex Architect for comprehensive design
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          echo "Running architecture stage for ${PROJECT_ID}"
          echo "Stage 4: Architecture completed"
  
  stage-4-b-dispatch:
    # Dynamic Task Matrix Generation
    # Reads execution_plan.yml from simulation and extracts parallel tasks
    # Outputs a JSON matrix for dynamic parallel job execution
    runs-on: ubuntu-latest
    needs: [initialize-pipeline, stage-4-architecture]
    if: |
      always() &&
      (needs.stage-4-architecture.result == 'success' || github.event.inputs.stage == 'implementation' || github.event.inputs.stage == 'all')
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      has_tasks: ${{ steps.generate-matrix.outputs.has_tasks }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      
      - name: Generate Task Matrix
        id: generate-matrix
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          EXECUTION_PLAN=".somas/projects/${PROJECT_ID}/artifacts/execution_plan.yml"
          
          echo "Checking for execution plan at: ${EXECUTION_PLAN}"
          
          # Check if execution plan exists
          if [ ! -f "${EXECUTION_PLAN}" ]; then
            echo "Warning: Execution plan not found. Using fallback sequential mode."
            # Fallback: single sequential task
            MATRIX='{"include":[{"task_id":"FALLBACK-001","task_name":"Sequential Implementation","task_desc":"Execute implementation in sequential mode","duration":24}]}'
            echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT
            echo "has_tasks=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Validate YAML syntax
          if ! yq eval '.' "${EXECUTION_PLAN}" > /dev/null 2>&1; then
            echo "Error: Invalid YAML in execution plan. Using fallback mode."
            MATRIX='{"include":[{"task_id":"FALLBACK-001","task_name":"Sequential Implementation","task_desc":"Execute implementation in sequential mode","duration":24}]}'
            echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT
            echo "has_tasks=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Extract parallel tasks from Phase 2 (Core Implementation)
          # Try to find the first phase with parallel_tasks
          PHASE_COUNT=$(yq eval '.optimal_execution_plan | keys | length' "${EXECUTION_PLAN}" 2>/dev/null || echo "0")
          
          if [ "${PHASE_COUNT}" -eq "0" ]; then
            echo "Warning: No phases found in execution plan. Using fallback mode."
            MATRIX='{"include":[{"task_id":"FALLBACK-001","task_name":"Sequential Implementation","task_desc":"Execute implementation in sequential mode","duration":24}]}'
            echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT
            echo "has_tasks=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Find first phase with parallel_tasks (typically phase_2 for implementation)
          TASKS_JSON="[]"
          for phase in phase_1 phase_2 phase_3 phase_4 phase_5; do
            PARALLEL_TASKS=$(yq eval ".optimal_execution_plan.${phase}.parallel_tasks // []" "${EXECUTION_PLAN}" 2>/dev/null)
            
            if [ "${PARALLEL_TASKS}" != "[]" ] && [ "${PARALLEL_TASKS}" != "null" ]; then
              echo "Found parallel tasks in ${phase}"
              
              # Convert YAML array to JSON matrix format
              # Create Python script for task conversion
              printf '%s\n' \
                'import sys' \
                'import json' \
                '' \
                'try:' \
                '    tasks = json.load(sys.stdin)' \
                '    if not tasks:' \
                '        print("[]")' \
                '        sys.exit(0)' \
                '    ' \
                '    matrix_tasks = []' \
                '    for task in tasks:' \
                '        matrix_task = {' \
                '            "task_id": task.get("task_id", "UNKNOWN"),' \
                '            "task_name": task.get("name", "Unknown Task"),' \
                '            "task_desc": task.get("name", "Implementation task"),' \
                '            "duration": task.get("duration", 8)' \
                '        }' \
                '        matrix_tasks.append(matrix_task)' \
                '    ' \
                '    print(json.dumps(matrix_tasks))' \
                'except Exception as e:' \
                '    print("[]", file=sys.stderr)' \
                '    print("[]")' \
                > /tmp/convert_tasks.py
              
              TASKS_JSON=$(yq eval -o=json ".optimal_execution_plan.${phase}.parallel_tasks" "${EXECUTION_PLAN}" | python3 /tmp/convert_tasks.py)
              
              # Exit loop if we found tasks
              if [ "${TASKS_JSON}" != "[]" ]; then
                break
              fi
            fi
          done
          
          # If no parallel tasks found, use fallback
          if [ "${TASKS_JSON}" = "[]" ] || [ -z "${TASKS_JSON}" ]; then
            echo "No parallel tasks found in execution plan. Using fallback mode."
            MATRIX='{"include":[{"task_id":"FALLBACK-001","task_name":"Sequential Implementation","task_desc":"Execute implementation in sequential mode","duration":24}]}'
            echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT
            echo "has_tasks=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Wrap in matrix format
          printf '%s\n' \
            'import sys' \
            'import json' \
            '' \
            'tasks = json.load(sys.stdin)' \
            'matrix = {"include": tasks}' \
            'print(json.dumps(matrix))' \
            > /tmp/wrap_matrix.py
          
          MATRIX=$(echo "${TASKS_JSON}" | python3 /tmp/wrap_matrix.py)
          
          printf '%s\n' \
            'import sys' \
            'import json' \
            'print(len(json.load(sys.stdin)))' \
            > /tmp/count_tasks.py
          
          TASK_COUNT=$(echo "${TASKS_JSON}" | python3 /tmp/count_tasks.py)
          echo "Generated matrix with ${TASK_COUNT} tasks"
          echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT
          echo "has_tasks=true" >> $GITHUB_OUTPUT
  
  stage-5-implementation:
    # Agent Assignment: @copilot somas-implementer + Codex Coder
    # Supporting Agents:
    #   - @copilot somas-tester: Creates comprehensive test suites
    #   - @copilot somas-security: Reviews security implementation
    #   - @copilot somas-optimizer: Optimizes performance
    #   - @copilot somas-documenter: Documents code and APIs
    # Responsible for: Production-ready code generation with 80%+ test coverage
    # Output: Source code, tests, documentation in implementation/ directory
    # 
    # DYNAMIC PARALLEL EXECUTION:
    # This job uses a matrix strategy driven by the simulation's execution_plan.yml
    # Tasks run in parallel based on the optimized task graph from Monte Carlo simulation
    runs-on: ubuntu-latest
    needs: [initialize-pipeline, stage-4-b-dispatch]
    if: |
      always() &&
      needs.stage-4-b-dispatch.result == 'success' &&
      needs.stage-4-b-dispatch.outputs.has_tasks == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.stage-4-b-dispatch.outputs.matrix) }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install Python Dependencies
        run: |
          pip install pyyaml
      
      - name: Execute Implementation Task
        # Agents: Multi-agent collaboration for complete implementation
        # - @copilot somas-implementer: Generates code
        # - @copilot somas-tester: Creates test suites (80%+ coverage)
        # - @copilot somas-security: Security scanning and validation
        # - @copilot somas-optimizer: Performance optimization
        # - @copilot somas-documenter: Code and API documentation
        env:
          TASK_ID: ${{ matrix.task_id }}
          TASK_NAME: ${{ matrix.task_name }}
          TASK_DESC: ${{ matrix.task_desc }}
          PROJECT_ID: ${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}
        run: |
          echo "========================================"
          echo "Executing Task: ${TASK_NAME}"
          echo "Task ID: ${TASK_ID}"
          echo "Project: ${PROJECT_ID}"
          echo "========================================"
          
          # Define and validate required context files for the task
          SPEC_FILE=".somas/projects/${PROJECT_ID}/artifacts/SPEC.md"
          ARCH_FILE=".somas/projects/${PROJECT_ID}/artifacts/ARCHITECTURE.md"
          PLAN_FILE=".somas/projects/${PROJECT_ID}/artifacts/execution_plan.yml"
          
          for context_file in "${SPEC_FILE}" "${ARCH_FILE}" "${PLAN_FILE}"; do
            if [ ! -f "${context_file}" ]; then
              echo "ERROR: Required context file not found: ${context_file}"
              echo "Ensure that specification, simulation, and architecture stages have completed successfully for project ${PROJECT_ID}."
              exit 1
            fi
          done
          
          CONTEXT_FILES="${SPEC_FILE},${ARCH_FILE},${PLAN_FILE}"
          
          # Define output path for this task
          OUTPUT_PATH=".somas/projects/${PROJECT_ID}/artifacts/tasks/${TASK_ID}_result.md"
          
          # Execute task using the runner
          python3 somas/core/runner.py \
            --agent "coder" \
            --task_name "${TASK_NAME}" \
            --task_desc "${TASK_DESC}" \
            --context_files "${CONTEXT_FILES}" \
            --output_path "${OUTPUT_PATH}" \
            --project_id "${PROJECT_ID}"
          
          echo "Task ${TASK_ID} completed successfully"
      
      - name: Commit Task Results
        run: |
          git config user.name "SOMAS Bot"
          git config user.email "somas-bot@users.noreply.github.com"
          
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          
          # Check if there are any changes to commit
          if git status --porcelain .somas/projects/${PROJECT_ID}/artifacts/ | grep . >/dev/null; then
            git add .somas/projects/${PROJECT_ID}/artifacts/
            git commit -m "Complete task ${{ matrix.task_id }}: ${{ matrix.task_name }}"
            git push
          else
            echo "No changes to commit for task ${{ matrix.task_id }}"
          fi
  
  stage-6-validation:
    # Agent Assignment: Gemini Validator (primary)
    # Supporting Agents:
    #   - @copilot somas-reviewer: Pre-validation code review
    #   - @copilot somas-security: Security audit
    #   - @copilot somas-tester: Test verification
    #   - @copilot somas-debugger: Bug investigation if failures found
    # Responsible for: Independent quality verification and validation
    # Output: Validation report, test results, security scan results
    runs-on: ubuntu-latest
    needs: [initialize-pipeline, stage-5-implementation]
    if: |
      always() &&
      (needs.stage-5-implementation.result == 'success' || github.event.inputs.stage == 'validation' || github.event.inputs.stage == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Run Validation Stage
        # Agents: Multi-agent quality verification
        # - @copilot somas-reviewer: Code quality review
        # - @copilot somas-security: Security vulnerability scanning
        # - Gemini Validator: Independent validation
        # - @copilot somas-debugger: Debug any failures found
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          echo "Running validation stage for ${PROJECT_ID}"
          echo "Stage 6: Validation completed"
  
  stage-7-staging:
    # Agent Assignment: @copilot somas-merger + Codex Deployer
    # Supporting Agents:
    #   - @copilot somas-orchestrator: Final pipeline coordination
    #   - @copilot somas-documenter: Deployment documentation
    # Responsible for: Merge preparation and deployment staging
    # Output: Clean merge, deployment documentation, ready for human approval
    runs-on: ubuntu-latest
    needs: [initialize-pipeline, stage-6-validation]
    if: |
      always() &&
      (needs.stage-6-validation.result == 'success' || github.event.inputs.stage == 'staging' || github.event.inputs.stage == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Run Staging Stage
        # Agents: Final preparation for human approval
        # - @copilot somas-merger: Resolves merge conflicts
        # - @copilot somas-orchestrator: Final status aggregation
        # - Codex Deployer: Deployment preparation
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          echo "Running staging stage for ${PROJECT_ID}"
          echo "Stage 7: Staging completed"
      
      - name: Close Project
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'somas-project-event',
              client_payload: {
                project_id: '${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}',
                action: 'close'
              }
            });
  
  record-metrics:
    runs-on: ubuntu-latest
    needs: [stage-7-staging]
    if: always()
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Record Pipeline Metrics
        run: |
          PROJECT_ID="${{ needs.initialize-pipeline.outputs.project_id || github.event.inputs.project_id }}"
          
          # Record metrics to analytics
          mkdir -p .somas/analytics/runs
          cat > .somas/analytics/runs/${PROJECT_ID}_metrics.json << EOF
          {
            "project_id": "${PROJECT_ID}",
            "completed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "stages": {
              "ideation": "${{ needs.stage-1-ideation.result }}",
              "specification": "${{ needs.stage-2-specification.result }}",
              "simulation": "${{ needs.stage-3-simulation.result }}",
              "architecture": "${{ needs.stage-4-architecture.result }}",
              "implementation": "${{ needs.stage-5-implementation.result }}",
              "validation": "${{ needs.stage-6-validation.result }}",
              "staging": "${{ needs.stage-7-staging.result }}"
            }
          }
          EOF
          
          echo "Recorded metrics for ${PROJECT_ID}"
